/*
 * This file was generated by the Gradle 'init' task.
 */

subprojects {
    apply plugin: 'java-library'
    apply plugin: 'maven-publish'

    repositories {
//      mavenLocal() // Don't use mavenLocal by default
        mavenCentral()
        maven {
            allowInsecureProtocol true
            url = psqr_private_maven_snapshot_local_repository_url
            credentials {
                username psqr_private_maven_repository_username
                password psqr_private_maven_repository_password
            }
            mavenContent {
                snapshotsOnly()
            }
        }

        maven {
            allowInsecureProtocol true
            url = psqr_private_maven_releases_local_repository_url
            credentials {
                username psqr_private_maven_repository_username
                password psqr_private_maven_repository_password
            }
            mavenContent {
                releasesOnly()
            }
        }
    }

    dependencies {
        implementation "org.jsoup:jsoup:1.15.3"
        testImplementation 'org.mockito:mockito-core:3.1.0'
        testImplementation 'junit:junit:4.12'
    }

    javadoc {
        options.tags = ["Refactor"]
    }

    jar {
        manifest {
            attributes(
                    'Implementation-Title': project.name,
                    'Implementation-Version': project.version,
                    'Implementation-Vendor-Id': project.group,
                    'Implementation-Vendor': 'Persequor ApS',
                    'Created-By': "Gradle $project.gradle.gradleVersion"
            )
        }
    }

    test {
        filter {
            excludeTestsMatching "*IT"
            excludeTestsMatching "*Manual"
        }

        if(JavaVersion.current() != JavaVersion.VERSION_1_8){
            jvmArgs "--add-opens", "java.base/jdk.internal.util.random=ALL-UNNAMED"
        }
    }

    task integrationTest(type: Test) {
        System.properties.each {
            if (it.key.startsWith("XS")) {
                systemProperties[it.key.substring(2)] = it.value
            }
        }
        filter {
            setFailOnNoMatchingTests(false)
            includeTestsMatching "*IT"
        }
    }

    task manualTest(type: Test) {
        System.properties.each {
            if (it.key.startsWith("XS")) {
                systemProperties[it.key.substring(2)] = it.value
            }
        }
        filter {
            setFailOnNoMatchingTests(false)
            includeTestsMatching "*Manual"
        }
    }

    task sqlOnlyIntegrationTest(type: Test) {
        System.properties.each {
            if (it.key.startsWith("XS")) {
                systemProperties[it.key.substring(2)] = it.value
            }
        }
        filter {
            setFailOnNoMatchingTests(false)
            excludeTestsMatching "*Cassandra*"
            includeTestsMatching "*IT"
        }
    }

    task sqlOnlyManualTest(type: Test) {
        System.properties.each {
            if (it.key.startsWith("XS")) {
                systemProperties[it.key.substring(2)] = it.value
            }
        }
        filter {
            setFailOnNoMatchingTests(false)
            excludeTestsMatching "*Cassandra*"
            includeTestsMatching "*Manual"
        }
    }

    sourceCompatibility = JavaVersion.VERSION_17

    configurations.all {
    }

    tasks.register('compileAssets', Tar) {
        from 'assets'
        archiveClassifier = "assets"
        destinationDirectory = file("$buildDir/libs")
    }

    publishing {
        publications {
            psqrPublication(MavenPublication) {
                from(components.java)
                artifact compileAssets
            }
        }
        repositories {
            // Publication to Maven is based on if we pass a project property as in ./gradlew publish -PpublishPublic
            // to select private repo (default) or public repository.
            // 'publish public' is our known term for stages releasing publicly.
            // It is design to be called twice from CI build pipeline instead of publishing to both in parallel.
            // This is to see if private publish succeeds first, before sharing anything publicly and because it is easier
            // to clean private artifact repo in case we need to re-run.
            // We also want to call both publishing tasks individually because only the public one is done when it is a release build.
            if (project.hasProperty('publishPublic')) {
                maven {
                    allowInsecureProtocol true
                    name = 'psqr_public_maven'
                    url = psqr_public_maven_publish_release_local_repository_url
                    credentials {
                        username psqr_public_maven_publish_repository_username
                        password psqr_public_maven_publish_repository_password
                    }
                }
            } else {
                maven {
                    allowInsecureProtocol true
                    name = 'psqr_private_maven'
                    url = version.endsWith('-SNAPSHOT') ? psqr_private_maven_publish_snapshot_local_repository_url : psqr_private_maven_publish_release_local_repository_url
                    credentials {
                        username psqr_private_maven_publish_repository_username
                        password psqr_private_maven_publish_repository_password
                    }
                }
            }
        }
    }
    if (!version.endsWith("-SNAPSHOT")) {
        // This ensure if the version number is a release version (do not end with SNAPSHOT)
        // then we do not allow any other dependency to end with SNAPSHOT either and fail resolution
        configurations*.resolutionStrategy*.eachDependency { details ->
            if (details.requested.version.endsWith("-SNAPSHOT")) {
                throw new GradleException("Update your snapshot dependencies to release versions. Release build should not contain snapshot dependencies: " + details.requested)
            }
        }
    }

    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
    }
}
